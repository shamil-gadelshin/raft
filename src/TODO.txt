TODO: Features:

Main algorithm:
- rsm
    .append sync on entry-commit
- operation_log replication
    .enforce elections timeout
    .operation_log forcing from the leader (clear entries with invalid terms and indices
        .empty (heartbeat) AppendEntries on node's current operation_log index evaluating
    .support max AppendEntries size parameter & max AppendEntries number


Details:
- stability
    .crossbeam recv, send - parse result
    .check channels bounded-unbounded types
    .check channels overflows
    .project timeouts
    .on termination - shutdown communication workers first
    .remove channel.send().expect - handle disconnection error (because of node termination)
- investigate
    .detect faster split votes by counting votes??
    .Check commit index on restart with existing log, should be safe with 0(zero)
    .futures
    .election trait?
    .rebuild raft election as rsm: implement explicit transitions causes (received AppendEntryRequest, HeartbeatWaitingTimeExpired, etc)
- identity
    .generic
    .libp2p
- communication
    .libp2p
    .grpc
    .change client and node response patterns (after committing to the operation_log)
    .service discovery for network-communication (peer)
- system events logging
    .remove requests from log messages
    .increase log coverage
- error handling
    .communication timeouts
- node example
    .remove node_id from log
    .implement peer network communicator
        .implement service discovery
    .graceful-shutdown for KILL signals
    .configuration
        .cmd params
        .file (toml?)
- code style
    .clear #[allow(dead_code)]
    .investigate & remove use crate::
    .introduce aliases (Arc<Mutex<Node<Log>>>)
    .enforce code line length limit
    .rustfmt
    .clippy
- release
    .consensus
    .implement Display
    .travis-ci
    .consider #![forbid(unsafe_code, missing_docs)]
- debug
    .tests
    .cases
        .no quorum
        .low election timeout
        .low communication timeout
        .check committed only applied to rsm
        .single node
        .add new separate node, when add to cluster - ensure conversion to follower and log replication
        .cases description in file
        .election
            .invalid term (stale)
            .newer term - convert to follower
                .leader
                .candidate
            .incorrect leader sends heartbeats
    .conditional compilation
- user-friendliness
    .readme.md
    .documentation
        .add the top of the main file: #![warn(missing_docs, unsafe_code)]
        .comment .proto
    .license
    .Rust API Guidelines
- optimization
    .speed & memory profiling
    .mutex
        .consider to pass node_id as a copy to reduce mutex locks
        .consider replacing mutex with cas (or RW-lock) for nodes
        .migrate Mutex to parking_lot implementation
    .RW-lock for communicator
    .optional abort channel for peers notifier (election) (abort_election_event_rx in notify_peers fn)


Future Features:
- transfer leadership
- cluster membership changes
    .remove server
        .shutdown self
    .add_server
        .TIMEOUT response: replicate log in rounds
- log compaction
    .file snapshot
        .load on start
- client RPC
    .sessions - for duplicate request handling
    .support match_index for node state
    .read query
- rsm
    .persistent
        .load on start
- operation-log
    .add failure reason to AppendEntryResponse
    .park-unpark the send_heartbeat_append_entries thread - remove unnecessary mutex-lock

Done:
- support single node
- investigate
    .Replicate State Machine or Rsm?
    .investigate channels faults
    .'static in the 'Log : LogStorage + Sync + Send+ 'static'
    .Arc<dyn Log> to get rid of &static + Send ...
    .worker thread structure: all peer-request thread, client-thread?
    .extract communicator trait
    .timeouts to NodeConfig as separate struct
- rsm support
- leader election
    .check log on votes
- communication
    .channel communication
    .tarpc (won't do)
    .client_requests support
        .server api
        .separate client_requests
- modules create
- cluster_membership changes
    .add server
    .change quorum size
- system events logging
    .introduce logging system (remove print_event())
        .response to the client after majority of the servers responses
- operation_log
    .persist server's current term and vote and cluster configuration (state persistence)
    .response to the client after majority of the servers responses
    .memory snapshot
    .empty (heartbeat) AppendEntries on node's current operation_log index evaluating
    .not commit entry if quorum fails (clear entry?)
    .transmit full cluster configuration on AddServer Rpc
    .log (instead of Rsm) is responsible for cluster_configuration apply
    .append_entries: respond for no quorum
- error handling
    .error style
    .de-box errors to RaftError
- project structure
    .library crate
    .exe-project
    .dev-dependencies
        .env-logger
    .raft vs infrastructure module(code) separation
- release
    .graceful-shutdown
- optimization
    .rayon on nodes requests

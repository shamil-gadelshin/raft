TODO: Features:

Main algorithm:
- fsm
    .append sync on entry-commit
- operation_log replication
    .persist server's current term and vote and cluster configuration (state persistence)
    .operation_log forcing from the leader (clear entries with invalid terms and indices
        .empty (heartbeat) AppendEntries on node's current operation_log index evaluating
    .support max AppendEntries size parameter & max AppendEntries number
    .append_entries: process equal terms

Details:
- stability
    .crossbeam recv, send - parse result
    .check channels bounded-unbounded types
    .check channels overflows
    .project timeouts
    .investigate channels faults
- investigate
   .Arc<dyn Log> to get rid of &static + Send ...
   .futures
   .election trait?
   .rebuild raft election as fsm: implement explicit transitions causes (received AppendEntryRequest, HeartbeatWaitingTimeExpired, etc)
- identity
    .generic
    .libp2p
- communication
    .libp2p
    .grpc
    .change client and node response patterns (after committing to the operation_log)
- system events logging
    .remove requests from log messages
    .increase log coverage
- error handling
    .communication timeouts
- project structure
    .separate client?
    .exe-project
        .remove node_id from log
- code style
    .clear #[allow(dead_code)]
    .investigate & remove use crate::
    .introduce aliases (Arc<Mutex<Node<Log>>>)
    .enforce code line length limit
    .rustfmt
    .clippy
- release
    .consensus
    .implement Display
    .configuration
        .cmd params
        .file (toml?)
    .travis-ci
- debug
    .tests
    .cases
        .cases description in file
        .election
            .invalid term (stale)
            .newer term - convert to follower
                .leader
                .candidate
            .incorrect leader sends heartbeats
    .conditional compilation
- user-friendliness
    .readme.md
    .documentation
        .add the top of the main file: #![warn(missing_docs, unsafe_code)]
        .comment .proto
    .license
    .Rust API Guidelines
- optimization
    .rayon on nodes requests
    .speed & memory profiling
    .consider replacing mutex with cas (or RW-lock) for nodes
    .RW-lock for communicator
    .optional abort channel for peers notifier (election) (abort_election_event_rx in notify_peers fn)
    .migrate Mutex to parking_lot implementation

Future Features:
- transfer leadership
- cluster membership changes
    .remove server
        .shutdown self
- log compaction
    .file snapshot
        .load on start
- client RPC
    .sessions - for duplicate request handling
    .read query
- fsm
    .persistent
        .load on start


Done:
- investigate
    .'static in the 'Log : LogStorage + Sync + Send+ 'static'
    .worker thread structure: all peer-request thread, client-thread?
   .extract communicator trait
- fsm support
- leader election
    .check log on votes

- communication
    .channel communication
    .tarpc (won't do)
    .client_requests support
        .server api
        .separate client_requests
- modules create
- cluster_membership changes
    .add server
    .change quorum size
- system events logging
    .introduce logging system (remove print_event())
        .response to the client after majority of the servers responses
- operation_log
    .response to the client after majority of the servers responses
    .memory snapshot
    .empty (heartbeat) AppendEntries on node's current operation_log index evaluating
    .not commit entry if quorum fails (clear entry?)
- error handling
    .error style
- project structure
    .library crate
    .exe-project
    .dev-dependencies
        .env-logger
    .raft vs infrastructure module(code) separation

